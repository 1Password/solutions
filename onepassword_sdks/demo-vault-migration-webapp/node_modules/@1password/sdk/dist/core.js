"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedCore = void 0;
const sdk_core_1 = require("@1password/sdk-core");
const types_1 = require("./types");
const errors_1 = require("./errors");
// In empirical tests, we determined that maximum message size that can cross the FFI boundary
// is ~64MB. Past this limit, the wasm-bingen FFI will throw an error and the program will crash.
// We set the limit to 50MB to be safe, to be reconsidered upon further testing.
const messageLimit = 50 * 1024 * 1024;
/**
 *  An implementation of the `Core` interface that shares resources across all clients.
 */
class SharedCore {
    initClient(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const serializedConfig = JSON.stringify(config);
            try {
                return yield (0, sdk_core_1.init_client)(serializedConfig);
            }
            catch (e) {
                (0, errors_1.throwError)(e);
            }
        });
    }
    invoke(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const serializedConfig = JSON.stringify(config, types_1.ReplacerFunc);
            // Encoding to bytes as JS uses UTF-16 under the hood, but the messages
            // that are sent across the FFI boundary are encoded in UTF-8.
            if (new TextEncoder().encode(serializedConfig).length > messageLimit) {
                (0, errors_1.throwError)(`message size exceeds the limit of ${messageLimit} bytes, please contact 1Password at support@1password.com or https://developer.1password.com/joinslack if you need help."`);
            }
            try {
                return yield (0, sdk_core_1.invoke)(serializedConfig);
            }
            catch (e) {
                (0, errors_1.throwError)(e);
            }
        });
    }
    invoke_sync(config) {
        const serializedConfig = JSON.stringify(config, types_1.ReplacerFunc);
        // Encoding to bytes as JS uses UTF-16 under the hood, but the messages
        // that are sent across the FFI boundary are encoded in UTF-8.
        if (new TextEncoder().encode(serializedConfig).length > messageLimit) {
            (0, errors_1.throwError)(`message size exceeds the limit of ${messageLimit} bytes, please contact 1Password at support@1password.com or https://developer.1password.com/joinslack if you need help.`);
        }
        try {
            return (0, sdk_core_1.invoke_sync)(serializedConfig);
        }
        catch (e) {
            (0, errors_1.throwError)(e);
        }
    }
    releaseClient(clientId) {
        const serializedId = JSON.stringify(clientId);
        (0, sdk_core_1.release_client)(serializedId);
    }
}
exports.SharedCore = SharedCore;

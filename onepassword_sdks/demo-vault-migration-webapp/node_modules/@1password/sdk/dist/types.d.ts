export type ErrorMessage = string;
/** Additional attributes for OTP fields. */
export interface AddressFieldDetails {
    /** The street address */
    street: string;
    /** The city */
    city: string;
    /** The country */
    country: string;
    /** The ZIP code */
    zip: string;
    /** The state */
    state: string;
}
export interface DocumentCreateParams {
    /** The name of the file */
    name: string;
    /** The content of the file */
    content: Uint8Array;
}
export interface FileAttributes {
    /** The name of the file */
    name: string;
    /** The ID of the file retrieved from the server */
    id: string;
    /** The size of the file in bytes */
    size: number;
}
export interface FileCreateParams {
    /** The name of the file */
    name: string;
    /** The content of the file */
    content: Uint8Array;
    /** The section id where the file should be stored */
    sectionId: string;
    /** The field id where the file should be stored */
    fieldId: string;
}
/**
 * For future use, if we want to return more information about the generated password.
 * Currently, it only returns the password itself.
 */
export interface GeneratePasswordResponse {
    /** The generated password. */
    password: string;
}
export declare enum ItemCategory {
    Login = "Login",
    SecureNote = "SecureNote",
    CreditCard = "CreditCard",
    CryptoWallet = "CryptoWallet",
    Identity = "Identity",
    Password = "Password",
    Document = "Document",
    ApiCredentials = "ApiCredentials",
    BankAccount = "BankAccount",
    Database = "Database",
    DriverLicense = "DriverLicense",
    Email = "Email",
    MedicalRecord = "MedicalRecord",
    Membership = "Membership",
    OutdoorLicense = "OutdoorLicense",
    Passport = "Passport",
    Rewards = "Rewards",
    Router = "Router",
    Server = "Server",
    SshKey = "SshKey",
    SocialSecurityNumber = "SocialSecurityNumber",
    SoftwareLicense = "SoftwareLicense",
    Person = "Person",
    Unsupported = "Unsupported"
}
export declare enum ItemFieldType {
    Text = "Text",
    Concealed = "Concealed",
    CreditCardType = "CreditCardType",
    CreditCardNumber = "CreditCardNumber",
    Phone = "Phone",
    Url = "Url",
    Totp = "Totp",
    Email = "Email",
    Reference = "Reference",
    SshKey = "SshKey",
    Menu = "Menu",
    MonthYear = "MonthYear",
    Address = "Address",
    Date = "Date",
    Unsupported = "Unsupported"
}
/** Field type-specific attributes. */
export type ItemFieldDetails = 
/** The computed OTP code and other details */
{
    type: "Otp";
    content: OtpFieldDetails;
}
/** Computed SSH Key attributes */
 | {
    type: "SshKey";
    content?: SshKeyAttributes;
}
/** Address components */
 | {
    type: "Address";
    content?: AddressFieldDetails;
};
/** Represents a field within an item. */
export interface ItemField {
    /** The field's ID */
    id: string;
    /** The field's title */
    title: string;
    /** The ID of the section containing the field. Built-in fields such as usernames and passwords don't require a section. */
    sectionId?: string;
    /** The field's type */
    fieldType: ItemFieldType;
    /** The string representation of the field's value */
    value: string;
    /** Field type-specific attributes. */
    details?: ItemFieldDetails;
}
/** A section groups together multiple fields in an item. */
export interface ItemSection {
    /** The section's unique ID */
    id: string;
    /** The section's title */
    title: string;
}
/**
 * Controls the auto-fill behavior of a website.
 *
 *
 * For more information, visit https://support.1password.com/autofill-behavior/
 */
export declare enum AutofillBehavior {
    /** Auto-fill any page thatâ€™s part of the website, including subdomains */
    AnywhereOnWebsite = "AnywhereOnWebsite",
    /** Auto-fill only if the domain (hostname and port) is an exact match. */
    ExactDomain = "ExactDomain",
    /** Never auto-fill on this website */
    Never = "Never"
}
export interface Website {
    /** The website URL */
    url: string;
    /** The label of the website, e.g. 'website', 'sign-in address' */
    label: string;
    /**
     * The auto-fill behavior of the website
     *
     * For more information, visit https://support.1password.com/autofill-behavior/
     */
    autofillBehavior: AutofillBehavior;
}
export interface ItemFile {
    /** the attributes of the file */
    attributes: FileAttributes;
    /** the section id where the file should be stored */
    sectionId: string;
    /** the field id where the file should be stored */
    fieldId: string;
}
/** Represents a 1Password item. */
export interface Item {
    /** The item's ID */
    id: string;
    /** The item's title */
    title: string;
    /** The item's category */
    category: ItemCategory;
    /** The ID of the vault where the item is saved */
    vaultId: string;
    /** The item's fields */
    fields: ItemField[];
    /** The item's sections */
    sections: ItemSection[];
    /** The notes of the item */
    notes: string;
    /** The item's tags */
    tags: string[];
    /** The websites used for autofilling for items of the Login and Password categories. */
    websites: Website[];
    /** The item's version */
    version: number;
    /** The item's file fields */
    files: ItemFile[];
    /** The document file for the Document item category */
    document?: FileAttributes;
    /** The time the item was created at */
    createdAt: Date;
    /** The time the item was updated at */
    updatedAt: Date;
}
export interface ItemCreateParams {
    /** The item's category */
    category: ItemCategory;
    /** The ID of the vault where the item is saved */
    vaultId: string;
    /** The item's title */
    title: string;
    /** The item's fields */
    fields?: ItemField[];
    /** The item's sections */
    sections?: ItemSection[];
    /** The item's notes */
    notes?: string;
    /** The item's tags */
    tags?: string[];
    /** The websites used for autofilling for items of the Login and Password categories. */
    websites?: Website[];
    /** The item's files stored as fields */
    files?: FileCreateParams[];
    /** The document file for the Document item type. Empty when the item isn't of Document type. */
    document?: DocumentCreateParams;
}
/** Represents a decrypted 1Password item overview. */
export interface ItemOverview {
    /** The item's ID */
    id: string;
    /** The item's title */
    title: string;
    /** The item's category */
    category: ItemCategory;
    /** The ID of the vault where the item is saved */
    vaultId: string;
    /** The websites used for autofilling for items of the Login and Password categories. */
    websites: Website[];
    /** The item tags */
    tags: string[];
    /** The time the item was created at */
    createdAt: Date;
    /** The time the item was updated at */
    updatedAt: Date;
}
/** The valid duration options for sharing an item */
export declare enum ItemShareDuration {
    /** The share will expire in one hour */
    OneHour = "OneHour",
    /** The share will expire in one day */
    OneDay = "OneDay",
    /** The share will expire in seven days */
    SevenDays = "SevenDays",
    /** The share will expire in fourteen days */
    FourteenDays = "FourteenDays",
    /** The share will expire in thirty days */
    ThirtyDays = "ThirtyDays"
}
/** The allowed types of item sharing, enforced by account policy */
export declare enum AllowedType {
    /** Allows creating share links with specific recipients */
    Authenticated = "Authenticated",
    /** Allows creating public share links */
    Public = "Public"
}
/** The allowed recipient types of item sharing, enforced by account policy */
export declare enum AllowedRecipientType {
    /** Recipients can be specified by email address */
    Email = "Email",
    /** Recipients can be specified by domain */
    Domain = "Domain"
}
/** The file sharing policy */
export interface ItemShareFiles {
    /** Whether files can be included in item shares */
    allowed: boolean;
    /** The maximum encrypted size (in bytes) an included file can be */
    maxSize: number;
    /** The allowed types of item sharing - either "Authenticated" (share to specific users) or "Public" (share to anyone with a link) */
    allowedTypes?: AllowedType[];
    /** The allowed recipient types of item sharing - either "Email" or "Domain" */
    allowedRecipientTypes?: AllowedRecipientType[];
    /** The maximum duration that an item can be shared for */
    maxExpiry?: ItemShareDuration;
    /** The default duration that an item is shared for */
    defaultExpiry?: ItemShareDuration;
    /** The maximum number of times an item can be viewed. A null value means unlimited views */
    maxViews?: number;
}
/**
 * The account policy for sharing items, set by your account owner/admin
 * This policy is enforced server-side when sharing items
 */
export interface ItemShareAccountPolicy {
    /** The maximum duration that an item can be shared for */
    maxExpiry: ItemShareDuration;
    /** The default duration that an item is shared for */
    defaultExpiry: ItemShareDuration;
    /** The maximum number of times an item can be viewed. A null value means unlimited views */
    maxViews?: number;
    /** The allowed types of item sharing - either "Authenticated" (share to specific users) or "Public" (share to anyone with a link) */
    allowedTypes: AllowedType[];
    /** The allowed recipient types of item sharing - either "Email" or "Domain" */
    allowedRecipientTypes: AllowedRecipientType[];
    /** The file sharing policy */
    files: ItemShareFiles;
}
/** The validated recipient of an item share */
export type ValidRecipient = 
/** This exact email address */
{
    type: "Email";
    parameters: {
        email: string;
    };
}
/** Anyone with an email address from the specified domain */
 | {
    type: "Domain";
    parameters: {
        domain: string;
    };
};
/**
 * The configuration options for sharing an item
 * These must respect the account policy on item sharing
 */
export interface ItemShareParams {
    /** Emails or domains of the item share recipients. If not provided, everyone with the share link will have access */
    recipients?: ValidRecipient[];
    /** The duration of the share in seconds. If not provided, defaults to the account policy's default expiry */
    expireAfter?: ItemShareDuration;
    /** Whether the item can only be viewed once per recipient */
    oneTimeOnly: boolean;
}
/** Additional attributes for OTP fields. */
export interface OtpFieldDetails {
    /** The OTP code, if successfully computed */
    code?: string;
    /** The error message, if the OTP code could not be computed */
    errorMessage?: string;
}
export interface Response<T, E> {
    content?: T;
    error?: E;
}
export interface ResolvedReference {
    secret: string;
    itemId: string;
    vaultId: string;
}
export type ResolveReferenceError = 
/** Error parsing the secret reference */
{
    type: "parsing";
    message: ErrorMessage;
}
/** The specified reference cannot be found within the item */
 | {
    type: "fieldNotFound";
    message?: undefined;
}
/** No vault matched the secret reference query */
 | {
    type: "vaultNotFound";
    message?: undefined;
}
/** More than one vault matched the secret reference query */
 | {
    type: "tooManyVaults";
    message?: undefined;
}
/** No item matched the secret reference query */
 | {
    type: "itemNotFound";
    message?: undefined;
}
/** More than one item matched the secret reference query */
 | {
    type: "tooManyItems";
    message?: undefined;
}
/** More than one field matched the provided secret reference */
 | {
    type: "tooManyMatchingFields";
    message?: undefined;
}
/** No section found within the item for the provided identifier */
 | {
    type: "noMatchingSections";
    message?: undefined;
}
/** Incompatiable TOTP query parameters */
 | {
    type: "incompatibleTOTPQueryParameterField";
    message?: undefined;
}
/** The totp was not able to be generated */
 | {
    type: "unableToGenerateTotpCode";
    message: ErrorMessage;
}
/** Couldn't find attributes specific to an SSH Key field */
 | {
    type: "sSHKeyMetadataNotFound";
    message?: undefined;
}
/** Currently only support text files */
 | {
    type: "unsupportedFileFormat";
    message?: undefined;
}
/** Trying to convert a non-private key to a private key format */
 | {
    type: "incompatibleSshKeyQueryParameterField";
    message?: undefined;
}
/** Unable to properly parse a private key string to convert to an internal Private Key type */
 | {
    type: "unableToParsePrivateKey";
    message?: undefined;
}
/** Unable to format a private key to OpenSSH format */
 | {
    type: "unableToFormatPrivateKeyToOpenSsh";
    message?: undefined;
}
/** Other type */
 | {
    type: "other";
    message?: undefined;
};
export interface ResolveAllResponse {
    individualResponses: Record<string, Response<ResolvedReference, ResolveReferenceError>>;
}
export interface SshKeyAttributes {
    /** The public part of the SSH Key */
    publicKey: string;
    /** The fingerprint of the SSH Key */
    fingerprint: string;
    /** The key type ("Ed25519" or "RSA, {length}-bit") */
    keyType: string;
}
/** Represents a decrypted 1Password vault. */
export interface VaultOverview {
    /** The vault's ID */
    id: string;
    /** The vault's title */
    title: string;
}
export type PasswordRecipe = {
    type: "Memorable";
    parameters: {
        /** The type of separator between chunks. */
        separatorType: SeparatorType;
        /** Uppercase one randomly selected chunk. */
        capitalize: boolean;
        /** The type of word list used. */
        wordListType: WordListType;
        /** The number of "words" (words or syllables). */
        wordCount: number;
    };
} | {
    type: "Pin";
    parameters: {
        /** Number of digits in the PIN. */
        length: number;
    };
} | {
    type: "Random";
    parameters: {
        /** Include at least one digit in the password. */
        includeDigits: boolean;
        /** Include at least one symbol in the password. */
        includeSymbols: boolean;
        /** The length of the password. */
        length: number;
    };
};
export declare enum SeparatorType {
    /**
     * Randomly selected digits.
     * E.g, "`correct4horse0battery1staple`"
     */
    Digits = "digits",
    /**
     * Randomly selected digits and symbols.
     * This is useful to get word-based passwords to meet complexity requirements
     * E.g, "`correct4horse-battery1staple`"
     */
    DigitsAndSymbols = "digitsAndSymbols",
    /**
     * Spaces, like the original Diceware.
     * Great for mobile keyboards, not so great when people can overhear you type the password.
     * E.g, "`correct horse battery staple`"
     */
    Spaces = "spaces",
    /**
     * Hyphens "`-`".
     * E.g, "`correct-horse-battery-staple`"
     */
    Hyphens = "hyphens",
    /**
     * "`_`".
     * E.g, "`correct_horse_battery_staple`"
     */
    Underscores = "underscores",
    /**
     * Period (full stop) "`.`".
     * E.g, "`correct.horse.battery.staple`"
     */
    Periods = "periods",
    /**
     * Comma "`,`".
     * E.g, "`correct,horse,battery,staple`"
     */
    Commas = "commas"
}
export declare enum WordListType {
    /** Agile wordlist */
    FullWords = "fullWords",
    /** English-like syllables */
    Syllables = "syllables",
    /** Three (random) letter "words" */
    ThreeLetters = "threeLetters"
}
/**
 * Custom JSON reviver and replacer functions for dynamic data transformation
 * ReviverFunc is used during JSON parsing to detect and transform specific data structures
 * ReplacerFunc is used during JSON serialization to modify certain values before stringifying.
 * These functions allow for flexible encoding and decoding of data, ensuring that complex types are properly handled when converting between TS objects and JSON
 */
export declare const ReviverFunc: (key: string, value: unknown) => unknown;
export declare const ReplacerFunc: (key: string, value: unknown) => unknown;
